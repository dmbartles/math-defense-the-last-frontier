<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Math Defense: The Last Frontier</title>
<link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
<style>
*{margin:0;padding:0;box-sizing:border-box}
body{background:#000;color:#33ff33;font-family:'Press Start 2P',monospace;overflow:hidden;height:100vh;width:100vw;display:flex;align-items:center;justify-content:center;image-rendering:pixelated}
#game-container{position:relative;width:800px;height:600px;max-width:100vw;max-height:100vh;overflow:hidden;background:#000}
canvas{display:block;width:100%;height:100%}

/* CRT Overlay */
#crt-overlay{position:absolute;top:0;left:0;width:100%;height:100%;pointer-events:none;z-index:100}
#crt-overlay::before{content:'';position:absolute;top:0;left:0;width:100%;height:100%;background:repeating-linear-gradient(0deg,transparent,transparent 2px,rgba(0,0,0,0.15) 2px,rgba(0,0,0,0.15) 4px);z-index:100}
#crt-overlay::after{content:'';position:absolute;top:0;left:0;width:100%;height:100%;background:radial-gradient(ellipse at center,transparent 60%,rgba(0,0,0,0.4) 100%);z-index:101}

/* UI Screens */
.screen{position:absolute;top:0;left:0;width:100%;height:100%;display:none;flex-direction:column;align-items:center;justify-content:center;z-index:50;padding:20px;text-align:center}
.screen.active{display:flex}

/* Title Screen */
#title-screen{background:#000}
#title-screen h1{font-size:18px;color:#ff6600;text-shadow:0 0 10px #ff6600,0 0 20px #ff3300;margin-bottom:10px;line-height:1.6}
#title-screen h2{font-size:10px;color:#ffcc00;margin-bottom:30px}
.insert-coin{font-size:14px;color:#fff;animation:blink 1s step-end infinite;margin-top:30px;cursor:pointer}
@keyframes blink{50%{opacity:0}}
.title-art{font-size:8px;color:#ff6600;line-height:1.2;margin-bottom:20px;white-space:pre}
.high-score-display{font-size:8px;color:#33ff33;margin-top:20px}

/* HUD */
#hud{position:absolute;top:0;left:0;width:100%;z-index:60;display:none;padding:6px 10px;background:rgba(0,0,0,0.7);border-bottom:2px solid #33ff33}
#hud.active{display:flex;justify-content:space-between;align-items:center;flex-wrap:wrap}
.hud-item{font-size:7px;color:#33ff33;margin:2px 5px}
.hud-item span{color:#ffcc00}
#trail-map{display:flex;gap:2px;align-items:center;margin-top:2px}
.trail-dot{width:6px;height:6px;background:#444;border-radius:50%}
.trail-dot.visited{background:#33ff33}
.trail-dot.current{background:#ffcc00;box-shadow:0 0 4px #ffcc00}
.trail-line{width:8px;height:2px;background:#444}
.trail-line.visited{background:#33ff33}

/* Answer Grid */
#answer-grid{position:absolute;bottom:0;left:0;width:100%;z-index:55;display:none;padding:8px;background:rgba(0,0,20,0.85);border-top:2px solid #33ff33}
#answer-grid.active{display:block}
#grid-container{display:grid;grid-template-columns:repeat(6,1fr);gap:4px;max-width:600px;margin:0 auto}
.grid-cell{font-size:10px;padding:8px 4px;text-align:center;background:#111;border:2px solid #225522;color:#33ff33;cursor:pointer;transition:all 0.1s;user-select:none}
.grid-cell:hover,.grid-cell.selected{background:#003300;border-color:#33ff33;color:#fff;text-shadow:0 0 5px #33ff33}
.grid-cell.correct{background:#005500;border-color:#00ff00;animation:flashCorrect 0.3s}
.grid-cell.wrong{background:#550000;border-color:#ff0000;animation:flashWrong 0.3s}
@keyframes flashCorrect{0%,100%{background:#005500}50%{background:#00ff00}}
@keyframes flashWrong{0%,100%{background:#550000}50%{background:#ff0000}}

/* Narrative Screen */
#narrative-screen{background:rgba(0,0,0,0.95);z-index:70}
#narrative-box{max-width:600px;width:90%;border:3px solid #8B4513;background:#1a0a00;padding:20px;position:relative}
#narrative-header{font-size:10px;color:#ffcc00;margin-bottom:15px;text-transform:uppercase}
#narrative-text{font-size:9px;color:#cc8844;line-height:2;min-height:60px;text-align:left}
#narrative-choices{margin-top:20px;display:flex;flex-direction:column;gap:8px}
.narrative-choice{font-size:8px;padding:10px;background:#2a1500;border:2px solid #8B4513;color:#cc8844;cursor:pointer;text-align:left;transition:all 0.2s}
.narrative-choice:hover{background:#3a2500;border-color:#ffcc00;color:#ffcc00}
#narrative-result{font-size:9px;color:#33ff33;margin-top:15px;line-height:2;display:none;text-align:left}
#continue-btn{font-size:10px;padding:10px 20px;background:#2a1500;border:2px solid #ffcc00;color:#ffcc00;cursor:pointer;margin-top:15px;display:none}
#continue-btn:hover{background:#3a2500}

/* Game Over Screen */
#gameover-screen{background:rgba(0,0,0,0.95);z-index:80}
#gameover-screen h2{font-size:16px;color:#ff3333;margin-bottom:20px}
.go-stat{font-size:9px;color:#33ff33;margin:8px 0;line-height:1.8}
#play-again-btn{font-size:12px;padding:12px 24px;background:transparent;border:2px solid #33ff33;color:#33ff33;cursor:pointer;margin-top:25px}
#play-again-btn:hover{background:#003300}

/* Wave Banner */
#wave-banner{position:absolute;top:50%;left:50%;transform:translate(-50%,-50%);z-index:65;display:none;text-align:center}
#wave-banner h2{font-size:14px;color:#ffcc00;text-shadow:0 0 10px #ffcc00}
#wave-banner p{font-size:9px;color:#ff6600;margin-top:8px}

/* Responsive */
@media(max-width:800px){
#game-container{width:100vw;height:100vh}
.hud-item{font-size:6px}
.grid-cell{font-size:8px;padding:6px 2px}
#title-screen h1{font-size:12px}
}
</style>
</head>
<body>
<div id="game-container">
<canvas id="game-canvas" width="800" height="600"></canvas>
<div id="crt-overlay"></div>

<!-- HUD -->
<div id="hud">
<div class="hud-item">SCORE: <span id="hud-score">0</span></div>
<div class="hud-item">AMMO: <span id="hud-ammo">10</span></div>
<div class="hud-item">WAVE: <span id="hud-wave">1</span></div>
<div class="hud-item" id="hud-town-name">Independence, MO</div>
<div class="hud-item">
<div id="trail-map"></div>
</div>
</div>

<!-- Title Screen -->
<div id="title-screen" class="screen active">
<div class="title-art">
    ___  ___      _   _       ____        __
   |  \/  |     | | | |     |  _ \  ___ / _| ___ _ __  ___  ___
   | |\/| | __ _| |_| |__   | | | |/ _ \ |_ / _ \ '_ \/ __|/ _ \
   | |  | |/ _` | __| '_ \  | |_| |  __/  _|  __/ | | \__ \  __/
   |_|  |_|\__,_|\__|_| |_| |____/ \___|_|  \___|_| |_|___/\___|
</div>
<h2>THE LAST FRONTIER</h2>
<p style="font-size:8px;color:#888;max-width:500px;line-height:2;margin-bottom:10px">Defend frontier towns from incoming missiles by solving math problems! Navigate the answer grid to lock on and fire!</p>
<p style="font-size:7px;color:#666;margin-bottom:5px">Arrow keys to move | ENTER to select | SPACE to target nearest</p>
<div class="insert-coin" id="start-btn">PRESS ENTER TO START</div>
<div class="high-score-display" id="title-high-score"></div>
</div>

<!-- Answer Grid -->
<div id="answer-grid">
<div id="grid-container"></div>
</div>

<!-- Wave Banner -->
<div id="wave-banner">
<h2 id="wave-title"></h2>
<p id="wave-subtitle"></p>
</div>

<!-- Narrative Screen -->
<div id="narrative-screen" class="screen">
<div id="narrative-box">
<div id="narrative-header"></div>
<div id="narrative-text"></div>
<div id="narrative-choices"></div>
<div id="narrative-result"></div>
<button id="continue-btn">CONTINUE</button>
</div>
</div>

<!-- Game Over Screen -->
<div id="gameover-screen" class="screen">
<h2>GAME OVER</h2>
<div class="go-stat">Miles Traveled: <span id="go-miles">0</span></div>
<div class="go-stat">Problems Solved: <span id="go-solved">0</span></div>
<div class="go-stat">Accuracy: <span id="go-accuracy">0%</span></div>
<div class="go-stat">Final Score: <span id="go-score">0</span></div>
<div class="go-stat" id="go-highscore"></div>
<button id="play-again-btn">PLAY AGAIN</button>
</div>
</div>

<script>
// ============================================================
// MATH DEFENSE: THE LAST FRONTIER
// ============================================================

// --- CONSTANTS ---
const W = 800, H = 600;
const GRID_COLS = 6, GRID_ROWS = 2;
const BUILDING_COUNT = 3;
const MAX_BUILDING_HP = 3;

// 8-bit color palette
const PAL = {
  bg: '#0a0a2e', sky: '#0d0d3d', ground: '#2d1b00',
  green: '#33ff33', yellow: '#ffcc00', orange: '#ff6600',
  red: '#ff3333', white: '#ffffff', dark: '#111111',
  brown: '#8B4513', missile: '#ff4444', counter: '#33ff33',
  explosion: '#ffcc00', building: '#aa8855', star: '#ffffff'
};

// Town data for 10 levels
const TOWNS = [
  { name: 'Independence, MO', miles: 0, backdrop: 'plains',
    story: 'Your journey begins in Independence, Missouri. The frontier awaits!' },
  { name: 'Fort Kearny, NE', miles: 319, backdrop: 'plains',
    story: 'You arrive at Fort Kearny. Soldiers warn of dangers ahead.' },
  { name: 'Chimney Rock, NE', miles: 560, backdrop: 'rocks',
    story: 'The great Chimney Rock rises from the plains. A landmark of progress!' },
  { name: 'Fort Laramie, WY', miles: 650, backdrop: 'fort',
    story: 'Fort Laramie offers rest and supplies. Traders barter eagerly.' },
  { name: 'Independence Rock, WY', miles: 830, backdrop: 'rocks',
    story: 'You carve your name in Independence Rock, as thousands have before.' },
  { name: 'South Pass, WY', miles: 950, backdrop: 'mountains',
    story: 'The Continental Divide! You cross through South Pass.' },
  { name: 'Fort Hall, ID', miles: 1150, backdrop: 'fort',
    story: 'Fort Hall bustles with travelers. The trail splits here.' },
  { name: 'Snake River, ID', miles: 1300, backdrop: 'river',
    story: 'The Snake River is treacherous. Many wagons have been lost here.' },
  { name: 'Blue Mountains, OR', miles: 1600, backdrop: 'mountains',
    story: 'The Blue Mountains test your resolve. Snow covers the peaks.' },
  { name: 'Oregon City, OR', miles: 1930, backdrop: 'city',
    story: 'Oregon City! You have reached the end of the trail!' }
];

// Narrative events
const NARRATIVE_EVENTS = [
  {
    title: 'RIVER CROSSING',
    text: 'You reach a wide river. A ferry operator offers to take you across, or you can ford the river yourself.',
    choices: [
      { text: 'Pay for the ferry (costs 20 points)', math: 'If the ferry costs $3 per person and you have 6 people, what is the total cost?', answer: 18, options: [12, 18, 24, 9], effect: { score: -20, ammo: 2 }, result: 'Safe crossing! The ferry operator gives you extra supplies.' },
      { text: 'Ford the river (risky but free)', math: 'The river is 48 feet wide. If your wagon moves 8 feet per minute, how many minutes to cross?', answer: 6, options: [4, 6, 8, 5], effect: { score: 10, ammo: 0 }, result: 'You made it across! A bit wet, but safe.' }
    ]
  },
  {
    title: 'SUPPLY STOP',
    text: 'A trading post appears. Your supplies are running low.',
    choices: [
      { text: 'Buy ammunition', math: 'Bullets come in packs of 7. If you buy 4 packs, how many bullets?', answer: 28, options: [21, 28, 35, 24], effect: { ammo: 5, score: 0 }, result: 'Well stocked! +5 ammo.' },
      { text: 'Buy repair materials', math: 'Planks cost $5 each. How much for 9 planks?', answer: 45, options: [40, 45, 50, 35], effect: { ammo: 0, score: 0, repair: 1 }, result: 'You repair a damaged building!' }
    ]
  },
  {
    title: 'WEATHER WARNING',
    text: 'Dark clouds gather on the horizon. A storm is coming!',
    choices: [
      { text: 'Push through the storm', math: 'You travel 12 miles per hour for 5 hours. How far do you go?', answer: 60, options: [50, 55, 60, 65], effect: { score: 30, ammo: -1 }, result: 'You pushed through! Bonus points, but lost some ammo in the mud.' },
      { text: 'Wait for it to pass', math: 'The storm lasts 3 hours. If you rest 2 extra hours, how many hours total?', answer: 5, options: [4, 5, 6, 3], effect: { score: 0, ammo: 1 }, result: 'Smart choice. You found extra supplies while waiting.' }
    ]
  },
  {
    title: 'FELLOW TRAVELERS',
    text: 'You meet another wagon train. They propose sharing resources.',
    choices: [
      { text: 'Share your food', math: 'You have 72 lbs of food and 8 people total. How many lbs each?', answer: 9, options: [7, 8, 9, 10], effect: { score: 20, ammo: 1 }, result: 'They share ammo in return! +1 ammo and bonus points.' },
      { text: 'Trade for information', math: 'They traveled 36 miles in 4 days. How many miles per day?', answer: 9, options: [7, 8, 9, 12], effect: { score: 15, ammo: 0 }, result: 'Valuable trail info! Bonus points.' }
    ]
  },
  {
    title: 'BROKEN WHEEL',
    text: 'One of your wagon wheels has cracked! You need to fix it fast.',
    choices: [
      { text: 'Fix it with spare parts', math: 'A wheel has 12 spokes. If 4 broke, how many remain?', answer: 8, options: [6, 7, 8, 9], effect: { score: 10, ammo: 0 }, result: 'Fixed! You are back on the trail.' },
      { text: 'Build a new wheel', math: 'You need 16 nails and have 2 boxes of 9. How many extra nails?', answer: 2, options: [1, 2, 3, 4], effect: { score: 5, ammo: 0, repair: 1 }, result: 'Brand new wheel and you repair a building too!' }
    ]
  },
  {
    title: 'GOLD PROSPECTOR',
    text: 'An old prospector offers to sell you a map to a gold claim.',
    choices: [
      { text: 'Buy the map (costs 30 points)', math: 'If gold nuggets weigh 6 ounces each and you find 7, what is the total weight?', answer: 42, options: [36, 42, 48, 35], effect: { score: 50, ammo: 0 }, result: 'The map was real! Big score bonus!' },
      { text: 'Politely decline', math: 'You have 45 points. If the map costs 30, how many would you have left?', answer: 15, options: [10, 15, 20, 25], effect: { score: 5, ammo: 2 }, result: 'You find ammo by the roadside instead.' }
    ]
  },
  {
    title: 'WILD ANIMALS',
    text: 'A herd of buffalo blocks the trail! What do you do?',
    choices: [
      { text: 'Hunt for food', math: 'Each buffalo provides 200 lbs of meat. If you catch 3, how many lbs total?', answer: 600, options: [400, 500, 600, 700], effect: { score: 25, ammo: -2 }, result: 'Plenty of food, but you used ammo hunting.' },
      { text: 'Wait for them to pass', math: 'The herd is 150 buffalo long, passing 25 per minute. How many minutes to wait?', answer: 6, options: [4, 5, 6, 8], effect: { score: 5, ammo: 0 }, result: 'Patient but safe. The trail is clear.' }
    ]
  },
  {
    title: 'MOUNTAIN PASS',
    text: 'The mountain pass is narrow and treacherous. Choose your path wisely.',
    choices: [
      { text: 'Take the high pass', math: 'The pass is 8,400 feet high. Base camp is at 5,600 feet. How many feet to climb?', answer: 2800, options: [2400, 2600, 2800, 3200], effect: { score: 30, ammo: 0 }, result: 'Breathtaking views and a shortcut! Bonus points!' },
      { text: 'Go around the mountain', math: 'Going around adds 24 miles at 6 miles per hour. How many extra hours?', answer: 4, options: [3, 4, 5, 6], effect: { score: 0, ammo: 3 }, result: 'Longer but safer. You found an ammo cache! +3 ammo.' }
    ]
  },
  {
    title: 'NATIVE TRADERS',
    text: 'Friendly native traders offer valuable goods. They want to barter.',
    choices: [
      { text: 'Trade blankets for arrows', math: 'You have 5 blankets. Each trades for 8 arrows. How many arrows total?', answer: 40, options: [30, 35, 40, 45], effect: { ammo: 4, score: 10 }, result: 'Great trade! +4 ammo.' },
      { text: 'Trade tools for a guide', math: 'A guide saves 3 days of travel. At 15 miles per day, how many miles saved?', answer: 45, options: [35, 40, 45, 50], effect: { score: 40, ammo: 0 }, result: 'The guide leads you on a shortcut! Big bonus!' }
    ]
  }
];

// Difficulty settings per level
function getDifficulty(level) {
  const l = Math.min(level, 10);
  return {
    missileSpeed: 0.3 + l * 0.12,
    maxMissiles: 2 + Math.floor(l * 0.8),
    spawnRate: Math.max(1200, 3500 - l * 250),
    totalMissiles: 5 + l * 2,
    ammo: Math.max(8, 15 - Math.floor(l * 0.5)),
    operations: l <= 3 ? ['+', '-'] : l <= 6 ? ['+', '-', '*'] : ['+', '-', '*', '/'],
    maxNumber: l <= 3 ? 10 : l <= 6 ? 12 : 15,
    multiStep: l >= 8
  };
}

// ============================================================
// AUDIO ENGINE
// ============================================================
class AudioEngine {
  constructor() {
    this.ctx = null;
    this.initialized = false;
  }

  init() {
    if (this.initialized) return;
    try {
      this.ctx = new (window.AudioContext || window.webkitAudioContext)();
      this.initialized = true;
    } catch(e) { console.log('No audio support'); }
  }

  play(type) {
    if (!this.ctx) return;
    const now = this.ctx.currentTime;
    switch(type) {
      case 'fire': this._beep(880, 0.08, 'square', 0.3); break;
      case 'hit': this._sweep(600, 100, 0.3, 'sawtooth', 0.3); break;
      case 'wrong': this._beep(150, 0.3, 'square', 0.2); this._beep(100, 0.3, 'square', 0.2, 0.15); break;
      case 'explode': this._noise(0.4, 0.4); break;
      case 'damage': this._sweep(400, 50, 0.5, 'sawtooth', 0.4); this._noise(0.3, 0.5); break;
      case 'wave': this._beep(523, 0.15, 'square', 0.2); this._beep(659, 0.15, 'square', 0.2, 0.15); this._beep(784, 0.2, 'square', 0.2, 0.3); break;
      case 'gameover': this._sweep(600, 80, 1.0, 'sawtooth', 0.3); break;
      case 'select': this._beep(660, 0.05, 'square', 0.15); break;
      case 'move': this._beep(440, 0.03, 'square', 0.1); break;
      case 'typewriter': this._beep(800, 0.02, 'square', 0.08); break;
      case 'victory': this._beep(523,0.12,'square',0.2); this._beep(659,0.12,'square',0.2,0.12); this._beep(784,0.12,'square',0.2,0.24); this._beep(1047,0.25,'square',0.25,0.36); break;
    }
  }

  _beep(freq, dur, type, vol, delay = 0) {
    const osc = this.ctx.createOscillator();
    const gain = this.ctx.createGain();
    osc.type = type;
    osc.frequency.value = freq;
    gain.gain.setValueAtTime(vol, this.ctx.currentTime + delay);
    gain.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime + delay + dur);
    osc.connect(gain);
    gain.connect(this.ctx.destination);
    osc.start(this.ctx.currentTime + delay);
    osc.stop(this.ctx.currentTime + delay + dur + 0.05);
  }

  _sweep(startFreq, endFreq, dur, type, vol) {
    const osc = this.ctx.createOscillator();
    const gain = this.ctx.createGain();
    osc.type = type;
    osc.frequency.setValueAtTime(startFreq, this.ctx.currentTime);
    osc.frequency.exponentialRampToValueAtTime(endFreq, this.ctx.currentTime + dur);
    gain.gain.setValueAtTime(vol, this.ctx.currentTime);
    gain.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime + dur);
    osc.connect(gain);
    gain.connect(this.ctx.destination);
    osc.start();
    osc.stop(this.ctx.currentTime + dur + 0.05);
  }

  _noise(dur, vol) {
    const bufferSize = this.ctx.sampleRate * dur;
    const buffer = this.ctx.createBuffer(1, bufferSize, this.ctx.sampleRate);
    const data = buffer.getChannelData(0);
    for (let i = 0; i < bufferSize; i++) data[i] = Math.random() * 2 - 1;
    const source = this.ctx.createBufferSource();
    const gain = this.ctx.createGain();
    source.buffer = buffer;
    gain.gain.setValueAtTime(vol, this.ctx.currentTime);
    gain.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime + dur);
    source.connect(gain);
    gain.connect(this.ctx.destination);
    source.start();
  }
}

// ============================================================
// MATH PROBLEM GENERATOR
// ============================================================
class MathGenerator {
  generate(ops, maxNum, multiStep) {
    if (multiStep && Math.random() < 0.3) return this._multiStep(ops, maxNum);
    const op = ops[Math.floor(Math.random() * ops.length)];
    let a, b, answer, problem;
    switch(op) {
      case '+':
        a = this._rand(1, maxNum); b = this._rand(1, maxNum);
        answer = a + b; problem = `${a} + ${b}`;
        break;
      case '-':
        a = this._rand(2, maxNum); b = this._rand(1, a);
        answer = a - b; problem = `${a} - ${b}`;
        break;
      case '*':
        a = this._rand(2, Math.min(maxNum, 12)); b = this._rand(2, Math.min(maxNum, 12));
        answer = a * b; problem = `${a} × ${b}`;
        break;
      case '/':
        b = this._rand(2, Math.min(maxNum, 12));
        answer = this._rand(1, Math.min(maxNum, 12));
        a = b * answer;
        problem = `${a} ÷ ${b}`;
        break;
    }
    return { problem, answer };
  }

  _multiStep(ops, maxNum) {
    const op1 = ops.includes('*') ? '*' : '+';
    const op2 = ops.includes('-') ? '-' : '+';
    let a, b, c, answer, problem;
    if (op1 === '*') {
      a = this._rand(2, 6); b = this._rand(2, 6); c = this._rand(1, 10);
      if (op2 === '-') {
        answer = a * b - c; problem = `${a} × ${b} - ${c}`;
        if (answer < 0) { answer = a * b + c; problem = `${a} × ${b} + ${c}`; }
      } else {
        answer = a * b + c; problem = `${a} × ${b} + ${c}`;
      }
    } else {
      a = this._rand(5, maxNum); b = this._rand(1, maxNum); c = this._rand(1, 5);
      answer = a + b - c; problem = `${a} + ${b} - ${c}`;
      if (answer < 0) { answer = a + b + c; problem = `${a} + ${b} + ${c}`; }
    }
    return { problem, answer };
  }

  generateDistractors(answer, count) {
    const distractors = new Set();
    distractors.add(answer);
    const strategies = [
      () => answer + this._rand(1, 5),
      () => answer - this._rand(1, Math.max(1, Math.min(5, answer - 1))),
      () => answer + 10,
      () => answer - 10,
      () => answer * 2,
      () => Math.floor(answer / 2),
      () => answer + this._rand(1, 3) * (Math.random() < 0.5 ? 1 : -1),
      () => this._rand(Math.max(1, answer - 15), answer + 15)
    ];
    let attempts = 0;
    while (distractors.size < count && attempts < 100) {
      const strat = strategies[Math.floor(Math.random() * strategies.length)];
      const val = strat();
      if (val > 0 && val !== answer && Number.isInteger(val)) distractors.add(val);
      attempts++;
    }
    while (distractors.size < count) distractors.add(this._rand(1, 100));
    return this._shuffle([...distractors]);
  }

  _rand(min, max) { return Math.floor(Math.random() * (max - min + 1)) + min; }
  _shuffle(arr) { for (let i = arr.length - 1; i > 0; i--) { const j = Math.floor(Math.random() * (i + 1)); [arr[i], arr[j]] = [arr[j], arr[i]]; } return arr; }
}

// ============================================================
// STAR FIELD (background)
// ============================================================
class StarField {
  constructor() {
    this.stars = [];
    for (let i = 0; i < 80; i++) {
      this.stars.push({
        x: Math.random() * W, y: Math.random() * (H * 0.65),
        size: Math.random() * 2 + 0.5,
        twinkle: Math.random() * Math.PI * 2,
        speed: Math.random() * 0.5 + 0.5
      });
    }
  }

  draw(ctx, time) {
    this.stars.forEach(s => {
      const alpha = 0.4 + 0.6 * Math.sin(s.twinkle + time * s.speed * 0.001);
      ctx.fillStyle = `rgba(255,255,255,${alpha})`;
      ctx.fillRect(Math.floor(s.x), Math.floor(s.y), Math.ceil(s.size), Math.ceil(s.size));
    });
  }
}

// ============================================================
// MAIN GAME CLASS
// ============================================================
class Game {
  constructor() {
    this.canvas = document.getElementById('game-canvas');
    this.ctx = this.canvas.getContext('2d');
    this.audio = new AudioEngine();
    this.math = new MathGenerator();
    this.stars = new StarField();

    // Game state
    this.state = 'title'; // title, playing, narrative, gameover, waveBanner
    this.score = 0;
    this.level = 1;
    this.ammo = 10;
    this.buildings = [];
    this.missiles = [];
    this.counterMissiles = [];
    this.explosions = [];
    this.particles = [];
    this.gridValues = [];
    this.gridSelected = 0;
    this.activeMissile = null;
    this.totalSolved = 0;
    this.totalAttempts = 0;
    this.missilesSpawned = 0;
    this.missilesThisWave = 0;
    this.lastSpawn = 0;
    this.waveComplete = false;
    this.difficulty = getDifficulty(1);
    this.time = 0;
    this.narrativeShown = false;

    // Init
    this._initBuildings();
    this._initGrid();
    this._bindInput();
    this._updateTrailMap();
    this._showHighScore();

    // Start loop
    this._loop = this._loop.bind(this);
    requestAnimationFrame(this._loop);
  }

  _initBuildings() {
    this.buildings = [];
    const groundY = H * 0.72;
    const spacing = W / (BUILDING_COUNT + 1);
    for (let i = 0; i < BUILDING_COUNT; i++) {
      this.buildings.push({
        x: spacing * (i + 1),
        y: groundY,
        hp: MAX_BUILDING_HP,
        width: 50,
        height: 45
      });
    }
  }

  _initGrid() {
    if (!this.activeMissile) {
      this.gridValues = [];
      for (let i = 0; i < GRID_COLS * GRID_ROWS; i++) this.gridValues.push(0);
      this._renderGrid();
      return;
    }
    const answer = this.activeMissile.answer;
    const values = this.math.generateDistractors(answer, GRID_COLS * GRID_ROWS);
    this.gridValues = values;
    this._renderGrid();
  }

  _renderGrid() {
    const container = document.getElementById('grid-container');
    container.innerHTML = '';
    this.gridValues.forEach((val, i) => {
      const cell = document.createElement('div');
      cell.className = 'grid-cell' + (i === this.gridSelected ? ' selected' : '');
      cell.textContent = val || '?';
      cell.dataset.index = i;
      cell.addEventListener('click', () => this._selectAnswer(i));
      container.appendChild(cell);
    });
  }

  _updateGridSelection() {
    const cells = document.querySelectorAll('.grid-cell');
    cells.forEach((c, i) => c.classList.toggle('selected', i === this.gridSelected));
  }

  _selectAnswer(index) {
    if (this.state !== 'playing' || !this.activeMissile) return;
    this.audio.init();

    const selected = this.gridValues[index];
    const cell = document.querySelectorAll('.grid-cell')[index];
    this.totalAttempts++;

    if (selected === this.activeMissile.answer) {
      // Correct!
      cell.classList.add('correct');
      this.audio.play('fire');
      this.totalSolved++;
      this.score += 10 * this.level;
      this._fireCounterMissile(this.activeMissile);
      this.activeMissile.targeted = true;

      // Find next untargeted missile
      setTimeout(() => this._targetNextMissile(), 300);
    } else {
      // Wrong
      cell.classList.add('wrong');
      this.audio.play('wrong');
      if (this.ammo > 0) {
        this.ammo--;
        this.score = Math.max(0, this.score - 5);
      } else {
        // Out of ammo — wrong answers cause building damage
        const alive = this.buildings.filter(b => b.hp > 0);
        if (alive.length > 0) {
          const b = alive[Math.floor(Math.random() * alive.length)];
          b.hp--;
          this.audio.play('damage');
          this._createExplosion(b.x, b.y - 20, '#ff4444');
        }
      }
      setTimeout(() => cell.classList.remove('wrong'), 300);
    }
    this._updateHUD();
  }

  _targetNextMissile() {
    const untargeted = this.missiles.filter(m => !m.targeted && !m.destroyed);
    if (untargeted.length > 0) {
      // Target the lowest (closest to buildings) missile
      untargeted.sort((a, b) => b.y - a.y);
      this.activeMissile = untargeted[0];
      this._initGrid();
    } else {
      this.activeMissile = null;
      this._initGrid();
    }
  }

  _fireCounterMissile(target) {
    const startX = W / 2;
    const startY = H * 0.7;
    this.counterMissiles.push({
      x: startX, y: startY,
      targetX: target.x, targetY: target.y,
      target: target,
      speed: 6,
      trail: []
    });
  }

  _spawnMissile() {
    if (this.missilesSpawned >= this.difficulty.totalMissiles) return;
    const activeMissileCount = this.missiles.filter(m => !m.destroyed).length;
    if (activeMissileCount >= this.difficulty.maxMissiles) return;

    const problem = this.math.generate(
      this.difficulty.operations,
      this.difficulty.maxNumber,
      this.difficulty.multiStep
    );

    // Target a random surviving building
    const alive = this.buildings.filter(b => b.hp > 0);
    if (alive.length === 0) return;
    const target = alive[Math.floor(Math.random() * alive.length)];

    const startX = Math.random() * (W - 100) + 50;
    this.missiles.push({
      x: startX, y: -20,
      startX: startX, startY: -20,
      targetX: target.x, targetY: target.y,
      speed: this.difficulty.missileSpeed,
      problem: problem.problem,
      answer: problem.answer,
      targeted: false,
      destroyed: false,
      progress: 0
    });
    this.missilesSpawned++;

    // Auto-target if no active missile
    if (!this.activeMissile) {
      this._targetNextMissile();
    }
  }

  _bindInput() {
    document.addEventListener('keydown', (e) => {
      this.audio.init();
      switch(this.state) {
        case 'title':
          if (e.key === 'Enter' || e.key === ' ') { e.preventDefault(); this._startGame(); }
          break;
        case 'playing':
          e.preventDefault();
          this._handleGameInput(e);
          break;
        case 'gameover':
          if (e.key === 'Enter' || e.key === ' ') { e.preventDefault(); this._startGame(); }
          break;
      }
    });

    document.getElementById('start-btn').addEventListener('click', () => {
      this.audio.init();
      this._startGame();
    });
    document.getElementById('play-again-btn').addEventListener('click', () => {
      this.audio.init();
      this._startGame();
    });
    document.getElementById('continue-btn').addEventListener('click', () => {
      this._continueFromNarrative();
    });
  }

  _handleGameInput(e) {
    const cols = GRID_COLS;
    const total = GRID_COLS * GRID_ROWS;
    switch(e.key) {
      case 'ArrowLeft':
        this.gridSelected = (this.gridSelected - 1 + total) % total;
        this._updateGridSelection();
        this.audio.play('move');
        break;
      case 'ArrowRight':
        this.gridSelected = (this.gridSelected + 1) % total;
        this._updateGridSelection();
        this.audio.play('move');
        break;
      case 'ArrowUp':
        this.gridSelected = (this.gridSelected - cols + total) % total;
        this._updateGridSelection();
        this.audio.play('move');
        break;
      case 'ArrowDown':
        this.gridSelected = (this.gridSelected + cols) % total;
        this._updateGridSelection();
        this.audio.play('move');
        break;
      case 'Enter':
        this._selectAnswer(this.gridSelected);
        break;
      case ' ':
        this._targetNearestMissile();
        break;
    }
  }

  _targetNearestMissile() {
    const untargeted = this.missiles.filter(m => !m.targeted && !m.destroyed);
    if (untargeted.length > 0) {
      untargeted.sort((a, b) => b.y - a.y);
      this.activeMissile = untargeted[0];
      this._initGrid();
      this.audio.play('select');
    }
  }

  _startGame() {
    this.state = 'playing';
    this.score = 0;
    this.level = 1;
    this.totalSolved = 0;
    this.totalAttempts = 0;
    this._initLevel();

    // Reset game over screen header in case it was changed by victory
    const goScreen = document.getElementById('gameover-screen');
    goScreen.querySelector('h2').textContent = 'GAME OVER';
    goScreen.querySelector('h2').style.color = '#ff3333';

    document.getElementById('title-screen').classList.remove('active');
    goScreen.classList.remove('active');
    document.getElementById('narrative-screen').classList.remove('active');
    document.getElementById('hud').classList.add('active');
    document.getElementById('answer-grid').classList.add('active');
    this._updateHUD();

    this.audio.play('wave');
    this._showWaveBanner();
  }

  _initLevel() {
    this.difficulty = getDifficulty(this.level);
    this.ammo = this.difficulty.ammo;
    this.missiles = [];
    this.counterMissiles = [];
    this.explosions = [];
    this.missilesSpawned = 0;
    this.missilesThisWave = 0;
    this.lastSpawn = 0;
    this.waveComplete = false;
    this.activeMissile = null;
    this.gridSelected = 0;
    this.narrativeShown = false;
    if (this.level === 1) this._initBuildings();
    this._initGrid();
    this._updateTrailMap();
  }

  _showWaveBanner() {
    const town = TOWNS[this.level - 1];
    document.getElementById('wave-title').textContent = `WAVE ${this.level}`;
    document.getElementById('wave-subtitle').textContent = town.name;
    document.getElementById('wave-banner').style.display = 'block';
    this.state = 'waveBanner';

    setTimeout(() => {
      document.getElementById('wave-banner').style.display = 'none';
      this.state = 'playing';
    }, 2000);
  }

  _updateHUD() {
    document.getElementById('hud-score').textContent = this.score;
    document.getElementById('hud-ammo').textContent = this.ammo;
    document.getElementById('hud-wave').textContent = this.level;
    document.getElementById('hud-town-name').textContent = TOWNS[this.level - 1].name;
  }

  _updateTrailMap() {
    const map = document.getElementById('trail-map');
    map.innerHTML = '';
    for (let i = 0; i < 10; i++) {
      if (i > 0) {
        const line = document.createElement('div');
        line.className = 'trail-line' + (i < this.level ? ' visited' : '');
        map.appendChild(line);
      }
      const dot = document.createElement('div');
      dot.className = 'trail-dot';
      if (i < this.level - 1) dot.classList.add('visited');
      if (i === this.level - 1) dot.classList.add('current');
      dot.title = TOWNS[i].name;
      map.appendChild(dot);
    }
  }

  _showHighScore() {
    const hs = localStorage.getItem('mathDefenseHighScore') || 0;
    const el = document.getElementById('title-high-score');
    if (hs > 0) el.textContent = `HIGH SCORE: ${hs}`;
  }

  // ---- NARRATIVE SYSTEM ----
  _showNarrative() {
    this.state = 'narrative';
    document.getElementById('answer-grid').classList.remove('active');
    document.getElementById('narrative-screen').classList.add('active');

    const event = NARRATIVE_EVENTS[Math.floor(Math.random() * NARRATIVE_EVENTS.length)];
    this.currentNarrative = event;

    // Town story intro
    const town = TOWNS[this.level - 1];
    document.getElementById('narrative-header').textContent = `${town.name} — ${event.title}`;

    // Typewriter effect for story
    const textEl = document.getElementById('narrative-text');
    textEl.textContent = '';
    const fullText = town.story + '\n\n' + event.text;
    let charIndex = 0;
    const typeInterval = setInterval(() => {
      if (charIndex < fullText.length) {
        textEl.textContent += fullText[charIndex];
        charIndex++;
        if (charIndex % 3 === 0) this.audio.play('typewriter');
      } else {
        clearInterval(typeInterval);
        this._showNarrativeChoices(event);
      }
    }, 30);
  }

  _showNarrativeChoices(event) {
    const choicesEl = document.getElementById('narrative-choices');
    choicesEl.innerHTML = '';
    document.getElementById('narrative-result').style.display = 'none';
    document.getElementById('continue-btn').style.display = 'none';

    event.choices.forEach((choice, i) => {
      const btn = document.createElement('div');
      btn.className = 'narrative-choice';
      btn.innerHTML = `${choice.text}<br><br><span style="color:#ffcc00;font-size:7px">SOLVE: ${choice.math}</span>`;

      // Show answer options
      const optContainer = document.createElement('div');
      optContainer.style.cssText = 'display:flex;gap:6px;margin-top:8px;flex-wrap:wrap';
      choice.options.forEach(opt => {
        const optBtn = document.createElement('div');
        optBtn.style.cssText = 'padding:6px 12px;border:1px solid #8B4513;cursor:pointer;font-size:8px;color:#ffcc00';
        optBtn.textContent = opt;
        optBtn.addEventListener('click', (e) => {
          e.stopPropagation();
          this._resolveNarrativeChoice(choice, opt);
        });
        optBtn.addEventListener('mouseenter', () => optBtn.style.borderColor = '#ffcc00');
        optBtn.addEventListener('mouseleave', () => optBtn.style.borderColor = '#8B4513');
        optContainer.appendChild(optBtn);
      });

      btn.appendChild(optContainer);
      choicesEl.appendChild(btn);
    });
  }

  _resolveNarrativeChoice(choice, selectedAnswer) {
    const resultEl = document.getElementById('narrative-result');
    const choicesEl = document.getElementById('narrative-choices');

    if (selectedAnswer === choice.answer) {
      resultEl.textContent = '✓ CORRECT! ' + choice.result;
      resultEl.style.color = '#33ff33';
      this.audio.play('hit');
      // Apply positive effects
      if (choice.effect.score) this.score += choice.effect.score;
      if (choice.effect.ammo) this.ammo = Math.max(0, this.ammo + choice.effect.ammo);
      if (choice.effect.repair) {
        const damaged = this.buildings.filter(b => b.hp < MAX_BUILDING_HP && b.hp > 0);
        if (damaged.length > 0) damaged[0].hp = Math.min(MAX_BUILDING_HP, damaged[0].hp + 1);
      }
    } else {
      resultEl.textContent = `✗ The answer was ${choice.answer}. You lose some time but continue on.`;
      resultEl.style.color = '#ff3333';
      this.audio.play('wrong');
    }

    choicesEl.innerHTML = '';
    resultEl.style.display = 'block';
    document.getElementById('continue-btn').style.display = 'inline-block';
    this._updateHUD();
  }

  _continueFromNarrative() {
    document.getElementById('narrative-screen').classList.remove('active');
    this.level++;
    if (this.level > 10) {
      this._victory();
      return;
    }
    this._initLevel();
    this.state = 'playing';
    document.getElementById('answer-grid').classList.add('active');
    this._updateHUD();
    this.audio.play('wave');
    this._showWaveBanner();
  }

  // ---- GAME OVER / VICTORY ----
  _gameOver() {
    this.state = 'gameover';
    this.audio.play('gameover');
    document.getElementById('hud').classList.remove('active');
    document.getElementById('answer-grid').classList.remove('active');

    const miles = TOWNS[Math.min(this.level - 1, 9)].miles;
    const accuracy = this.totalAttempts > 0 ? Math.round(this.totalSolved / this.totalAttempts * 100) : 0;

    document.getElementById('go-miles').textContent = miles;
    document.getElementById('go-solved').textContent = this.totalSolved;
    document.getElementById('go-accuracy').textContent = accuracy + '%';
    document.getElementById('go-score').textContent = this.score;

    const hs = parseInt(localStorage.getItem('mathDefenseHighScore') || '0');
    if (this.score > hs) {
      localStorage.setItem('mathDefenseHighScore', this.score);
      document.getElementById('go-highscore').textContent = '★ NEW HIGH SCORE! ★';
      document.getElementById('go-highscore').style.color = '#ffcc00';
    } else {
      document.getElementById('go-highscore').textContent = `High Score: ${hs}`;
      document.getElementById('go-highscore').style.color = '#33ff33';
    }

    document.getElementById('gameover-screen').classList.add('active');
  }

  _victory() {
    this.score += 500;
    this.audio.play('victory');

    this.state = 'gameover';
    document.getElementById('hud').classList.remove('active');
    document.getElementById('answer-grid').classList.remove('active');

    const goScreen = document.getElementById('gameover-screen');
    goScreen.querySelector('h2').textContent = 'YOU MADE IT TO OREGON!';
    goScreen.querySelector('h2').style.color = '#33ff33';

    document.getElementById('go-miles').textContent = '1930';
    document.getElementById('go-solved').textContent = this.totalSolved;
    const accuracy = this.totalAttempts > 0 ? Math.round(this.totalSolved / this.totalAttempts * 100) : 0;
    document.getElementById('go-accuracy').textContent = accuracy + '%';
    document.getElementById('go-score').textContent = this.score;

    const hs = parseInt(localStorage.getItem('mathDefenseHighScore') || '0');
    if (this.score > hs) {
      localStorage.setItem('mathDefenseHighScore', this.score);
      document.getElementById('go-highscore').textContent = '★ NEW HIGH SCORE! ★';
      document.getElementById('go-highscore').style.color = '#ffcc00';
    } else {
      document.getElementById('go-highscore').textContent = `High Score: ${hs}`;
      document.getElementById('go-highscore').style.color = '#33ff33';
    }

    goScreen.classList.add('active');
  }

  // ---- UPDATE LOOP ----
  _update(dt) {
    if (this.state !== 'playing') return;
    this.time += dt;

    // Spawn missiles
    if (this.time - this.lastSpawn > this.difficulty.spawnRate && this.missilesSpawned < this.difficulty.totalMissiles) {
      this._spawnMissile();
      this.lastSpawn = this.time;
    }

    // Update missiles
    this.missiles.forEach(m => {
      if (m.destroyed) return;
      m.progress += m.speed * dt * 0.001;
      m.x = m.startX + (m.targetX - m.startX) * m.progress;
      m.y = m.startY + (m.targetY - m.startY) * m.progress;

      // Hit building
      if (m.progress >= 1) {
        m.destroyed = true;
        this._missileHitBuilding(m);
      }
    });

    // Update counter missiles
    this.counterMissiles.forEach(cm => {
      if (cm.done) return;
      const dx = cm.targetX - cm.x;
      const dy = cm.targetY - cm.y;
      const dist = Math.sqrt(dx * dx + dy * dy);
      if (dist < 10) {
        cm.done = true;
        if (!cm.target.destroyed) {
          cm.target.destroyed = true;
          this._createExplosion(cm.target.x, cm.target.y);
          this.audio.play('hit');
        }
      } else {
        cm.trail.push({ x: cm.x, y: cm.y, alpha: 1 });
        if (cm.trail.length > 15) cm.trail.shift();
        cm.x += (dx / dist) * cm.speed;
        cm.y += (dy / dist) * cm.speed;
      }
    });

    // Update explosions
    this.explosions.forEach(e => {
      e.radius += 1.5;
      e.alpha -= 0.02;
    });
    this.explosions = this.explosions.filter(e => e.alpha > 0);

    // Update particles
    this.particles.forEach(p => {
      p.x += p.vx;
      p.y += p.vy;
      p.vy += 0.1;
      p.life -= 0.02;
    });
    this.particles = this.particles.filter(p => p.life > 0);

    // Counter missile trail fade
    this.counterMissiles.forEach(cm => {
      cm.trail.forEach(t => t.alpha -= 0.03);
    });

    // Check wave completion
    const allSpawned = this.missilesSpawned >= this.difficulty.totalMissiles;
    const allDone = this.missiles.every(m => m.destroyed);
    const allCounterDone = this.counterMissiles.every(cm => cm.done);

    if (allSpawned && allDone && allCounterDone && !this.waveComplete) {
      this.waveComplete = true;
      setTimeout(() => {
        if (!this.narrativeShown) {
          this.narrativeShown = true;
          this._showNarrative();
        }
      }, 1000);
    }

    // Check game over
    if (this.buildings.every(b => b.hp <= 0)) {
      this._gameOver();
    }
  }

  _missileHitBuilding(missile) {
    const building = this.buildings.find(b =>
      b.hp > 0 &&
      Math.abs(b.x - missile.targetX) < b.width &&
      Math.abs(b.y - missile.targetY) < b.height
    );
    if (building) {
      building.hp--;
      this.audio.play('damage');
      this._createExplosion(missile.targetX, missile.targetY, '#ff4444');
      // Shake effect via particles
      for (let i = 0; i < 12; i++) {
        this.particles.push({
          x: missile.targetX, y: missile.targetY,
          vx: (Math.random() - 0.5) * 4, vy: -Math.random() * 5,
          color: Math.random() < 0.5 ? '#ff6600' : '#aa8855',
          life: 1
        });
      }
    }
    if (this.activeMissile === missile) {
      this._targetNextMissile();
    }
  }

  _createExplosion(x, y, color) {
    this.explosions.push({ x, y, radius: 5, alpha: 1, color: color || PAL.explosion });
    for (let i = 0; i < 8; i++) {
      this.particles.push({
        x, y,
        vx: (Math.random() - 0.5) * 6,
        vy: (Math.random() - 0.5) * 6,
        color: Math.random() < 0.5 ? PAL.explosion : PAL.orange,
        life: 1
      });
    }
  }

  // ---- DRAW ----
  _draw() {
    const ctx = this.ctx;
    ctx.clearRect(0, 0, W, H);

    // Sky gradient
    const grad = ctx.createLinearGradient(0, 0, 0, H * 0.75);
    grad.addColorStop(0, '#05051a');
    grad.addColorStop(0.7, '#0a0a3d');
    grad.addColorStop(1, '#1a0a2e');
    ctx.fillStyle = grad;
    ctx.fillRect(0, 0, W, H * 0.75);

    // Stars
    this.stars.draw(ctx, this.time);

    // Draw backdrop based on level
    this._drawBackdrop(ctx);

    // Ground
    ctx.fillStyle = PAL.ground;
    ctx.fillRect(0, H * 0.72, W, H * 0.28);
    ctx.fillStyle = '#3d2b10';
    ctx.fillRect(0, H * 0.72, W, 3);

    // Buildings
    this._drawBuildings(ctx);

    // Missiles
    this._drawMissiles(ctx);

    // Counter missiles
    this._drawCounterMissiles(ctx);

    // Explosions
    this._drawExplosions(ctx);

    // Particles
    this._drawParticles(ctx);

    // Active missile indicator
    this._drawActiveIndicator(ctx);
  }

  _drawBackdrop(ctx) {
    const town = TOWNS[this.level - 1];
    const groundY = H * 0.72;
    ctx.save();

    switch(town.backdrop) {
      case 'plains':
        // Rolling hills
        ctx.fillStyle = '#1a1a00';
        ctx.beginPath();
        ctx.moveTo(0, groundY);
        for (let x = 0; x <= W; x += 20) {
          ctx.lineTo(x, groundY - 10 - Math.sin(x * 0.01 + this.level) * 15);
        }
        ctx.lineTo(W, groundY);
        ctx.fill();
        break;
      case 'rocks':
        // Rock formations
        ctx.fillStyle = '#2a1a1a';
        const rockPositions = [[100, 40], [350, 60], [600, 35], [700, 50]];
        rockPositions.forEach(([rx, rh]) => {
          ctx.beginPath();
          ctx.moveTo(rx - 20, groundY);
          ctx.lineTo(rx - 5, groundY - rh);
          ctx.lineTo(rx + 5, groundY - rh - 10);
          ctx.lineTo(rx + 15, groundY - rh);
          ctx.lineTo(rx + 30, groundY);
          ctx.fill();
        });
        break;
      case 'mountains':
        ctx.fillStyle = '#1a1a2e';
        ctx.beginPath();
        ctx.moveTo(0, groundY);
        ctx.lineTo(100, groundY - 80);
        ctx.lineTo(200, groundY - 40);
        ctx.lineTo(350, groundY - 120);
        ctx.lineTo(450, groundY - 60);
        ctx.lineTo(550, groundY - 100);
        ctx.lineTo(650, groundY - 50);
        ctx.lineTo(750, groundY - 90);
        ctx.lineTo(800, groundY - 30);
        ctx.lineTo(800, groundY);
        ctx.fill();
        // Snow caps
        ctx.fillStyle = '#aaaacc';
        ctx.beginPath();
        ctx.moveTo(340, groundY - 120);
        ctx.lineTo(350, groundY - 120);
        ctx.lineTo(360, groundY - 115);
        ctx.lineTo(345, groundY - 110);
        ctx.fill();
        break;
      case 'fort':
        // Fort walls
        ctx.fillStyle = '#3a2a1a';
        ctx.fillRect(50, groundY - 40, 15, 40);
        ctx.fillRect(50, groundY - 50, 15, 10);
        ctx.fillRect(735, groundY - 40, 15, 40);
        ctx.fillRect(735, groundY - 50, 15, 10);
        // Flag
        ctx.fillStyle = '#666';
        ctx.fillRect(57, groundY - 70, 2, 20);
        ctx.fillStyle = '#ff4444';
        ctx.fillRect(59, groundY - 70, 12, 8);
        break;
      case 'river':
        // River
        ctx.fillStyle = '#1a3a5a';
        ctx.beginPath();
        ctx.moveTo(0, groundY + 20);
        for (let x = 0; x <= W; x += 10) {
          ctx.lineTo(x, groundY + 20 + Math.sin(x * 0.02 + this.time * 0.001) * 5);
        }
        ctx.lineTo(W, groundY + 40);
        ctx.lineTo(0, groundY + 40);
        ctx.fill();
        // Shimmer
        ctx.fillStyle = 'rgba(100,150,255,0.1)';
        for (let x = 0; x < W; x += 40) {
          const shimmerY = groundY + 22 + Math.sin(x * 0.05 + this.time * 0.002) * 3;
          ctx.fillRect(x, shimmerY, 20, 1);
        }
        break;
      case 'city':
        // City buildings in background
        ctx.fillStyle = '#2a2a2a';
        const cityBuildings = [[30,30],[80,50],[130,35],[180,60],[700,45],[740,55],[770,30]];
        cityBuildings.forEach(([cx, ch]) => {
          ctx.fillRect(cx, groundY - ch, 30, ch);
          // Windows
          ctx.fillStyle = '#ffcc00';
          for (let wy = groundY - ch + 5; wy < groundY - 5; wy += 10) {
            ctx.fillRect(cx + 5, wy, 4, 4);
            ctx.fillRect(cx + 15, wy, 4, 4);
          }
          ctx.fillStyle = '#2a2a2a';
        });
        break;
    }
    ctx.restore();
  }

  _drawBuildings(ctx) {
    this.buildings.forEach((b, i) => {
      if (b.hp <= 0) {
        // Rubble
        ctx.fillStyle = '#4a3a2a';
        ctx.fillRect(b.x - 25, b.y - 5, 50, 10);
        ctx.fillStyle = '#3a2a1a';
        ctx.fillRect(b.x - 15, b.y - 8, 12, 8);
        ctx.fillRect(b.x + 5, b.y - 6, 8, 6);
        return;
      }

      const x = b.x - b.width / 2;
      const y = b.y - b.height;

      // Building body
      ctx.fillStyle = b.hp === 3 ? '#aa8855' : b.hp === 2 ? '#887744' : '#665533';
      ctx.fillRect(x, y, b.width, b.height);

      // Roof
      ctx.fillStyle = '#664422';
      ctx.beginPath();
      ctx.moveTo(x - 5, y);
      ctx.lineTo(b.x, y - 15);
      ctx.lineTo(x + b.width + 5, y);
      ctx.closePath();
      ctx.fill();

      // Door
      ctx.fillStyle = '#442200';
      ctx.fillRect(b.x - 5, b.y - 16, 10, 16);

      // Windows
      ctx.fillStyle = '#ffcc44';
      ctx.fillRect(x + 5, y + 8, 8, 8);
      ctx.fillRect(x + b.width - 13, y + 8, 8, 8);

      // HP bar
      const barWidth = 40;
      const barX = b.x - barWidth / 2;
      const barY = y - 22;
      ctx.fillStyle = '#333';
      ctx.fillRect(barX, barY, barWidth, 4);
      ctx.fillStyle = b.hp === 3 ? '#33ff33' : b.hp === 2 ? '#ffcc00' : '#ff3333';
      ctx.fillRect(barX, barY, barWidth * (b.hp / MAX_BUILDING_HP), 4);

      // Damage cracks
      if (b.hp < 3) {
        ctx.strokeStyle = '#333';
        ctx.lineWidth = 1;
        ctx.beginPath();
        ctx.moveTo(x + 10, y + 5);
        ctx.lineTo(x + 20, y + 20);
        ctx.lineTo(x + 15, y + 30);
        ctx.stroke();
      }
      if (b.hp < 2) {
        ctx.beginPath();
        ctx.moveTo(x + 30, y + 3);
        ctx.lineTo(x + 35, y + 15);
        ctx.lineTo(x + 40, y + 25);
        ctx.stroke();
      }
    });
  }

  _drawMissiles(ctx) {
    this.missiles.forEach(m => {
      if (m.destroyed) return;

      // Trail
      ctx.strokeStyle = 'rgba(255,68,68,0.3)';
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.moveTo(m.startX, Math.max(0, m.startY));
      ctx.lineTo(m.x, m.y);
      ctx.stroke();

      // Missile body
      ctx.fillStyle = PAL.missile;
      ctx.beginPath();
      ctx.arc(m.x, m.y, 6, 0, Math.PI * 2);
      ctx.fill();

      // Glow
      ctx.fillStyle = 'rgba(255,100,50,0.3)';
      ctx.beginPath();
      ctx.arc(m.x, m.y, 10, 0, Math.PI * 2);
      ctx.fill();

      // Problem label
      ctx.font = '10px "Press Start 2P"';
      ctx.fillStyle = '#fff';
      ctx.textAlign = 'center';
      const labelBg = ctx.measureText(m.problem);
      const padding = 4;
      ctx.fillStyle = 'rgba(0,0,0,0.7)';
      ctx.fillRect(m.x - labelBg.width / 2 - padding, m.y - 22, labelBg.width + padding * 2, 14);
      ctx.fillStyle = m === this.activeMissile ? '#ffcc00' : '#fff';
      ctx.fillText(m.problem, m.x, m.y - 12);
    });
  }

  _drawCounterMissiles(ctx) {
    this.counterMissiles.forEach(cm => {
      if (cm.done) return;

      // Trail
      cm.trail.forEach((t, i) => {
        if (t.alpha <= 0) return;
        ctx.fillStyle = `rgba(51,255,51,${t.alpha * 0.5})`;
        ctx.fillRect(t.x - 1, t.y - 1, 3, 3);
      });

      // Head
      ctx.fillStyle = PAL.counter;
      ctx.beginPath();
      ctx.arc(cm.x, cm.y, 3, 0, Math.PI * 2);
      ctx.fill();
      ctx.fillStyle = 'rgba(51,255,51,0.4)';
      ctx.beginPath();
      ctx.arc(cm.x, cm.y, 6, 0, Math.PI * 2);
      ctx.fill();
    });
  }

  _drawExplosions(ctx) {
    this.explosions.forEach(e => {
      const gradient = ctx.createRadialGradient(e.x, e.y, 0, e.x, e.y, e.radius);
      gradient.addColorStop(0, `rgba(255,255,200,${e.alpha})`);
      gradient.addColorStop(0.4, `rgba(255,200,50,${e.alpha * 0.8})`);
      gradient.addColorStop(0.7, `rgba(255,100,0,${e.alpha * 0.5})`);
      gradient.addColorStop(1, `rgba(255,50,0,0)`);
      ctx.fillStyle = gradient;
      ctx.beginPath();
      ctx.arc(e.x, e.y, e.radius, 0, Math.PI * 2);
      ctx.fill();
    });
  }

  _drawParticles(ctx) {
    this.particles.forEach(p => {
      ctx.fillStyle = p.color;
      ctx.globalAlpha = p.life;
      ctx.fillRect(p.x - 1, p.y - 1, 3, 3);
    });
    ctx.globalAlpha = 1;
  }

  _drawActiveIndicator(ctx) {
    if (!this.activeMissile || this.activeMissile.destroyed) return;
    const m = this.activeMissile;
    const pulse = Math.sin(this.time * 0.005) * 0.3 + 0.7;

    // Targeting reticle
    ctx.strokeStyle = `rgba(255,204,0,${pulse})`;
    ctx.lineWidth = 1;
    ctx.setLineDash([4, 4]);
    ctx.beginPath();
    ctx.arc(m.x, m.y, 16, 0, Math.PI * 2);
    ctx.stroke();
    ctx.setLineDash([]);

    // Crosshair
    ctx.beginPath();
    ctx.moveTo(m.x - 20, m.y); ctx.lineTo(m.x - 12, m.y);
    ctx.moveTo(m.x + 12, m.y); ctx.lineTo(m.x + 20, m.y);
    ctx.moveTo(m.x, m.y - 20); ctx.lineTo(m.x, m.y - 12);
    ctx.moveTo(m.x, m.y + 12); ctx.lineTo(m.x, m.y + 20);
    ctx.stroke();

    // Arrow pointing to answer grid
    ctx.fillStyle = `rgba(255,204,0,${pulse})`;
    ctx.font = '8px "Press Start 2P"';
    ctx.textAlign = 'center';
    ctx.fillText('▼ SOLVE ▼', m.x, m.y + 30);
  }

  // ---- MAIN LOOP ----
  _lastTime = 0;
  _loop(timestamp) {
    const dt = timestamp - this._lastTime;
    this._lastTime = timestamp;

    this._update(dt);
    if (this.state === 'playing' || this.state === 'waveBanner' || this.state === 'narrative' || this.state === 'gameover') {
      this._draw();
    } else if (this.state === 'title') {
      this._drawTitleBG(timestamp);
    }

    requestAnimationFrame(this._loop);
  }

  _drawTitleBG(time) {
    const ctx = this.ctx;
    ctx.clearRect(0, 0, W, H);
    const grad = ctx.createLinearGradient(0, 0, 0, H);
    grad.addColorStop(0, '#05051a');
    grad.addColorStop(1, '#1a0a2e');
    ctx.fillStyle = grad;
    ctx.fillRect(0, 0, W, H);
    this.stars.draw(ctx, time);

    // Ground
    ctx.fillStyle = PAL.ground;
    ctx.fillRect(0, H * 0.8, W, H * 0.2);

    // Silhouette buildings
    ctx.fillStyle = '#1a1000';
    const silhouettes = [[150,40],[300,55],[500,45],[650,50]];
    silhouettes.forEach(([sx, sh]) => {
      ctx.fillRect(sx - 20, H * 0.8 - sh, 40, sh);
      ctx.beginPath();
      ctx.moveTo(sx - 25, H * 0.8 - sh);
      ctx.lineTo(sx, H * 0.8 - sh - 12);
      ctx.lineTo(sx + 25, H * 0.8 - sh);
      ctx.fill();
    });

    // Animated missile in title
    const mx = 200 + Math.sin(time * 0.001) * 100;
    const my = 250 + time * 0.03 % 200;
    ctx.fillStyle = PAL.missile;
    ctx.beginPath();
    ctx.arc(mx, my % (H * 0.6), 4, 0, Math.PI * 2);
    ctx.fill();
    ctx.font = '8px "Press Start 2P"';
    ctx.fillStyle = '#fff';
    ctx.textAlign = 'center';
    ctx.fillText('3 + 4', mx, (my % (H * 0.6)) - 10);
  }
}

// ============================================================
// START
// ============================================================
window.addEventListener('load', () => {
  const game = new Game();
});
</script>
</body>
</html>
